<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Encoder/Decoder with 3D Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            text-align: center;
        }

        textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-size: 16px;
        }

        button {
            display: inline-block;
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        #resultContainer {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f9f9f9;
            overflow-wrap: break-word;
        }

        p {
            margin: 5px 0;
        }

        #dnaVisualizationContainer {
            width: 100%;
            height: 500px;
            margin-top: 20px;
            position: relative;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DNA Encoder/Decoder with 3D Visualization</h1>
        
        <h2>Step 1: Enter Text</h2>
        <textarea id="inputText" placeholder="Enter text here..."></textarea>
        <button id="encodeButton">Encode to DNA</button>
        <button id="decodeButton">Decode DNA</button>
        
        <h2>Results</h2>
        <div id="resultContainer">
            <h3>Encoded DNA:</h3>
            <p id="encodedDNA"></p>
            <h3>Decoded Text:</h3>
            <p id="decodedText"></p>
        </div>

        <div id="dnaVisualizationContainer"></div>
    </div>

    <!-- Load Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        const binaryToDNAMap = {
            '00': 'A',
            '01': 'C',
            '10': 'G',
            '11': 'T'
        };

        const DNAToBinaryMap = {
            'A': '00',
            'C': '01',
            'G': '10',
            'T': '11'
        };

        // Function to encode a string to DNA
        function encodeToDNA(input) {
            let binaryString = '';
            input.split('').forEach(char => {
                const ascii = char.charCodeAt(0);
                const binary = ascii.toString(2).padStart(8, '0');
                binaryString += binary;
            });

            let dnaSequence = '';
            for (let i = 0; i < binaryString.length; i += 2) {
                const pair = binaryString.substr(i, 2);
                const dnaBase = binaryToDNAMap[pair];
                dnaSequence += dnaBase;
            }

            document.getElementById('encodedDNA').innerText = dnaSequence;
            visualizeDNA(dnaSequence);

            return dnaSequence;
        }

        // Function to decode a DNA sequence back to text
        function decodeFromDNA(dnaSequence) {
            let binaryString = '';

            for (let base of dnaSequence) {
                binaryString += DNAToBinaryMap[base];
            }

            let decodedString = '';
            for (let i = 0; i < binaryString.length; i += 8) {
                const byte = binaryString.substr(i, 8);
                const charCode = parseInt(byte, 2);
                decodedString += String.fromCharCode(charCode);
            }

            document.getElementById('decodedText').innerText = decodedString;
            return decodedString;
        }

        // Event listeners for the buttons
        document.getElementById('encodeButton').addEventListener('click', () => {
            const inputText = document.getElementById('inputText').value;
            encodeToDNA(inputText);
        });

        document.getElementById('decodeButton').addEventListener('click', () => {
            const dnaSequence = document.getElementById('encodedDNA').innerText;
            decodeFromDNA(dnaSequence);
        });

        // DNA Visualization with Three.js
        function visualizeDNA(sequence) {
            const container = document.getElementById('dnaVisualizationContainer');
            container.innerHTML = ''; // Clear previous visualization

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement); 
            controls.enableZoom = true;  
            controls.enablePan = true;   
            controls.enableRotate = true; 

            const helixRadius = 5;
            const helixHeight = 0.8;

            function createDNAHelix(sequence) {
                const group = new THREE.Group();

                for (let i = 0; i < sequence.length; i++) {
                    const angle = i * 0.5;
                    const x = helixRadius * Math.cos(angle);
                    const z = helixRadius * Math.sin(angle);
                    const y = i * helixHeight;

                    const base = sequence[i];
                    const pair = getPair(base);
                    const baseColor = getColor(base);

                    // Create spheres for bases
                    const baseGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const baseMaterial = new THREE.MeshBasicMaterial({ color: baseColor });
                    const baseSphere = new THREE.Mesh(baseGeometry, baseMaterial);
                    baseSphere.position.set(x, y, z);

                    // Create spheres for paired bases on opposite side
                    const pairX = helixRadius * Math.cos(angle + Math.PI);
                    const pairZ = helixRadius * Math.sin(angle + Math.PI);
                    const pairColor = getColor(pair);

                    const pairMaterial = new THREE.MeshBasicMaterial({ color: pairColor });
                    const pairSphere = new THREE.Mesh(baseGeometry, pairMaterial);
                    pairSphere.position.set(pairX, y, pairZ);

                    // Connect the pair with a line
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, y, z),
                        new THREE.Vector3(pairX, y, pairZ)
                    ]);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
                    const line = new THREE.Line(lineGeometry, lineMaterial);

                    group.add(baseSphere);
                    group.add(pairSphere);
                    group.add(line);
                }

                return group;
            }

            function getPair(base) {
                switch (base) {
                    case 'A': return 'T';
                    case 'T': return 'A';
                    case 'C': return 'G';
                    case 'G': return 'C';
                    default: return 'A';
                }
            }

            function getColor(base) {
                switch (base) {
                    case 'A': return 0xff0000; // Red
                    case 'T': return 0x00ff00; // Green
                    case 'C': return 0x007bff; // Blue
                    case 'G': return 0xffff00; // Yellow
                    default: return 0xffffff; // White
                }
            }

            const dnaHelix = createDNAHelix(sequence);
            scene.add(dnaHelix);

            // Adjust camera position based on sequence length
            const boundingBox = new THREE.Box3().setFromObject(dnaHelix);
            const size = new THREE.Vector3();
            boundingBox.getSize(size);

            // Set camera to fit the entire helix and center it
            const center = boundingBox.getCenter(new THREE.Vector3());
            camera.position.set(center.x, center.y + size.y / 2, Math.max(size.x, size.y, size.z) * 1.5);
            camera.lookAt(center);

            // Resize the renderer and camera on window resize
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            animate();
        }
    </script>
</body>
</html>
